/*
    Little JS Starter Project
    - A simple starter project for LittleJS
    - Demos all the main engine features
    - Builds to a zip file
*/

'use strict';


// fix texture bleeding by shrinking tile slightly
tileFixBleedScale = .5;

// sound effects
const sound_click = new Sound([1,.5]);

// medals
const medal_example = new Medal(0, 'Example Medal', 'Welcome to LittleJS!');
medalsInit('Hello World');

// game variables
let particleEmitter;

///////////////////////////////////////////////////////////////////////////////
function gameInit()
{
    // create tile collision and visible tile layer
    initTileCollision(vec2(32,16));
    const pos = vec2();
    const tileLayer = new TileLayer(pos, tileCollisionSize);

    // get level data from the tiles image
    const tileImage = textureInfos[0].image;
    mainContext.drawImage(tileImage,0,0);
    const imageData = mainContext.getImageData(0,0,tileImage.width,tileImage.height).data;
    for (pos.x = tileCollisionSize.x; pos.x--;)
    for (pos.y = tileCollisionSize.y; pos.y--;)
    {
        // check if this pixel is set
        const i = pos.x + tileImage.width*(15 + tileCollisionSize.y - pos.y);
        if (!imageData[4*i])
            continue;
        
        // set tile data
        const tileIndex = 1;
        const direction = randInt(4)
        const mirror = !randInt(2);
        const color = randColor();
        const data = new TileLayerData(tileIndex, direction, mirror, color);
        tileLayer.setData(pos, data);
        setTileCollisionData(pos, 1);
    }

    // draw tile layer with new data
    tileLayer.redraw();

    // setup camera
    cameraPos = vec2(16,8);
    cameraScale = 48;

    // enable gravity
    gravity = -.01;

    // create particle emitter
    particleEmitter = new ParticleEmitter(
        vec2(16,9), 0,              // emitPos, emitAngle
        0, 0, 0, PI,              // emitSize, emitTime, emitRate, emiteCone
        tile(0, 16),                // tileIndex, tileSize
        hsl(1,1,1),   hsl(0,0,0),   // colorStartA, colorStartB
        hsl(0,0,0,0), hsl(0,0,0,0), // colorEndA, colorEndB
        2, .2, .2, .1, .05,   // time, sizeStart, sizeEnd, speed, angleSpeed
        .99, 1, 1, PI,        // damping, angleDamping, gravityScale, cone
        .05, .5, true, true         // fadeRate, randomness, collide, additive
    );
    particleEmitter.elasticity = .3; // bounce when it collides
    particleEmitter.trailScale = 2;  // stretch in direction of motion
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    if (mouseWasPressed(0))
    {
        // play sound when mouse is pressed
        sound_click.play(mousePos);

        // change particle color and set to fade out
        particleEmitter.colorStartA = hsl();
        particleEmitter.colorStartB = randColor();
        particleEmitter.colorEndA = particleEmitter.colorStartA.scale(1,0);
        particleEmitter.colorEndB = particleEmitter.colorStartB.scale(1,0);

        // unlock medals
        medal_example.unlock();
    }

    // move particles to mouse location if on screen
    if (mousePosScreen.x)
        particleEmitter.pos = mousePos;
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{

}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // draw a grey square in the background without using webgl
    drawRect(vec2(16,8), vec2(202,214), hsl(0,0,.6), 0, false);
    
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    drawNineSlice(vec2(10,10), vec2(4,4), tile(1))
}

function drawNineSlice(pos, size, tileInfo, context=overlayContext)
{
  // calculate the size of a slice
  const s = tileInfo.size.x / 3;

  // define the 9 parts as [x, y, width, height]
  const part1 = [0, 0, s, s];
  const part2 = [s, 0, s, s];
  const part3 = [s * 2, 0, s, s];
  const part4 = [0, s, s, s];
  const part5 = [s, s, s, s];
  const part6 = [s * 2, s, s, s];
  const part7 = [0, s * 2, s, s];
  const part8 = [s, s * 2, s, s];
  const part9 = [s * 2, s * 2, s, s];

  // target width/height (try different values!)
  const width = 16 * size.x;
  const height = 16 * size.y;

  const img = tileInfo.getTextureInfo().image;

  const originPos = pos.subtract(size.divide(vec2(2))).add(vec2( - 0.5));

  // draw the corners
  //context.imageSmoothingEnabled = false
  context.drawImage(img, ...part1, originPos.x + 0, originPos.y + 0, s + 1, s + 1); // top left
  context.drawImage(img, ...part3, originPos.x + width - s, originPos.y + 0, s + 1, s + 1); // top right
  context.drawImage(img, ...part7, originPos.x + 0, originPos.y + height - s, s + 1, s + 1); // bottom left
  context.drawImage(img, ...part9, originPos.x + width - s, originPos.y + height - s, s + 1, s + 1); // bottom right

  // draw the edges
  context.drawImage(img, ...part2, originPos.x + s, originPos.y + 0, width - 2 * s + 1, s + 1); // top
  context.drawImage(img, ...part8, originPos.x + s, originPos.y + height - s, width - 2 * s + 1, s + 1); // bottom
  context.drawImage(img, ...part4, originPos.x + 0, originPos.y + s, s + 1, height - 2 * s + 1); // left
  context.drawImage(img, ...part6, originPos.x + width - s, originPos.y + s, s + 1, height - 2 * s + 1); // right

  // draw the center
  context.drawImage(img, ...part5, originPos.x + s, originPos.y + s, width - 2 * s + 1, height - 2 * s + 1);
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost, ['tiles.png']);